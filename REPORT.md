| Лабораторная работа №2      | M3101                      | АОВС |
|-----------------------------|----------------------------| ---- |
| Построение логических схем  | Яворский Даниил Евгеньевич | 2024 |

## Инструментарий

- Icarus Verilog **v12-20220611**
- Logisim Evolution **3.8.0**

## Вариант

Были выполнены варианты logisim **normal**, verilog behaviour **normal**, verilog structural **normal**.

## Результат работы на тестовых данных: [ссылка на последний успешный action с актуальными данными](https://github.com/skkv-itmo-comp-arch/se-comp-arch24-circuit-spideydamn/actions/runs/8442065705)

# Описание

> Раздел, в котором вы описываете свою реализацию:
> 
> Что за схема вам дана, как она работает.
> 
> Как она была реализована (сколько ячеек памяти вы по итогу использовали, как "под капотом" работает ваша схема).
> 
> Если в вашей схеме реализованы также (де)мультиплексоры, триггеры и прочие непростые логических схемы, то нужно также расписать как они работают и зачем были использованы (коротко: что это такое и принцип работы, можно приводить таблицы истинности и временные диаграммы).
> 
> Если реализуется normal, то нужно описать как работают входовыходы и работа с 5 ячейками памяти (учитывая, что индекс может принимать значения от 0 до 7 включительно).
> Отдельно описать особенности сборки на Logisim, отдельно – на SystemVerilog.

## Logisim


Схему в Logisim я могу разделить на три большие категории:
- Счётчик (counter_mod5)
- Память на 4 бита (D_register_4)
- Дешифраторы (decoder_8)

### Счётчик

В счётчике у меня используются T-триггеры, если их можно так назвать. Их суть в том что они удваивают тактность. 
То есть, пока T сделает путь 0 -> 1 -> 0, Q изменится лишь один раз: 0->1 или 1->0.

В этом и заключается суть счетчика. Понятно, что при постоянном инкремировании по двоичным числам при смене i-1-го разряда дважды i-й разряд сменится только раз.
Зная это подведем Q младшего разряда к T среднего при инкременте, либо NOT_Q при дикременте. Соответственно конъюнкцию Q либо NOT_Q первых двух подводим к T третьего разряда.
Чтобы счетчик начинался с нуля при (5++) или с пяти при (0--) я поставил два AND гейта на 4 входа, 
куда идут соответственные Q или NOT_Q с каждого T-триггера в зависимости от того, 
какое значение нам нужно обработать (111 или 101) и значение с одно битного декодера, который определяет прибавляем мы единицу или вычитаем.
Вместе с RESET-ом полученные значения подключены к set и reset пинам всех T-триггеров в соответствии со значением, которое нам нужно получить (101->000, 111->100, RESET->100).

T-триггер в свою очередь это dynamic_D_trigger, у которого отрицательный выход связан с D.

dynamic_D_trigger это два D_trigger-а подключенные в цепочку, где сигнал C идет к первому нормально, а ко второму инвертированный.
Таким образом значение D проходит оба триггера, чтобы выйти на выход.

D-триггер представляет собой обычный триггер, в котором при C == 0 ничего не меняется, а при C == 1, Q = D, с небольшим дополнением в виде пинов set и reset, 
которые независимо ни от чего сбрасывают или устанавливают значение на выход.

### Память на 4 бита

D_register_4 представляет собой 4 обычных D-триггера, работающих независимо друг от друга.
Идея в том, что, чтобы записать значение в память, нужно выставить значение в пины D3, D2, D1, D0, при включенном C, при выключенном C значение регистра не изменяется.

dynamic_D_register_4 представляет собой 4 inverse динамических D-триггера, работающих независимо друг от друга.
Идея в том, что, чтобы записать значение в память, нужно сначала выставить значение в пины D3, D2, D1, D0, а затем включить и включить C.

inverse_dynamic_D_trigger это два D_trigger-а подключенные в цепочку, где сигнал C идет к первому инвертированный, а ко второму нормальный.

Так же для сброса или установки к каждому триггеру подведены проводы reset и set соответственно.

### Дешифраторы

Одно битный дешифратор decoder_2 устроен очень просто. При A == 0, Z1 = 0, Z0 = 1, а при A == 1, Z1 = 1, Z0 = 0.
Таким образом Если A == 1, установлен верхний выход, если A == 0, то нижний.

Двух битный дешифратор decoder_4 построен на базе двух одно битных. 
Здесь каждое входное значение идет в decoder_2, а затем результат обрабатывается 4 AND гейтами по следующим правилам:

| decoder_2_1 | decoder_2_2 | result |
|-------------|-------------|--------|
| z0          | z0          | Z0     |
| z0          | z1          | Z1     |
| z1          | z0          | Z2     |
| z1          | z1          | Z3     |

Трёх битный дешифратор работает подобно двух битному. Старший разряд подключается к одно битному дешифратору, остальные к двух битным соответственно своему номеру разряда.
И дальше, подобно двух битному, значения распределяются по восьми AND гейтам.


### Итого

Подсхема stack разделена на несколько областей.

#### Variables

Здесь все входные данные идут по своим tunnel во избежание огромного количества проводов.

#### Parsing

Здесь переменные распаршиваются на отдельные сигналы.

Command с помощью двух битного декодера распадается на 4 провода, каждый из который соответствует свой команде и идет в обычный D-register, 
чтобы при включенном CLK при смене COMMAND, распаршенная COMMAND не менялась и не ломала счетчик, когда у него одновременно входы С и dec_inc выключаются.

Index с помощью трех битного декодера распадается на 8 проводов.

Так же созданы провода push_time, push_pop_time, get_pop_time путем просто соединения CLK с командами в AND гейте, чтобы понимать когда какие действия выполнять.

Размещена схема счетчика, которой на вход в C дается ранее упомянутый push_pop_time. В dec_inc, который определяет инкрементирование или декрементирование, подаётся комманда push. 
Таким образом счетчик будет двигаться только когда будут производиться команды push или pop, при этом инкремент только при push.

И результат счетчика тоже распаршивается на провода Z4, Z3, Z2, Z1, Z0 в соответствии с номером ячейки стека, на которую он указывает.

#### Memory

В данном блоке размещены пять регистров по 4 бита для того, чтобы хранить все значения стека. 

К ним ко всем подведен провод RESET для сброса, и and гейты с push_time и номером ячейки (провода Z4, Z3, Z2, Z1, Z0 (см. Parsing)), в которую будут записываться значения с провода DATA_in при операции push.

Все выходы соединены с probe для отслеживания значений стека.

#### Output parser
В данном блоке я просто разбираю каждый случай для вывода каждой ячейки. Он разделен на логические блоки соответствующие каждой ячейке.
Для каждой ячейки просто отдельно рассматривается каждый индекс и номер ячейки при которой она будет подана на вывод при команде get, и номер ячейки, для вывода по команде pop.
В последнем блоке вспомогательные or гейты для компактности строения.

#### Output memory

Здесь я просто записываю в регистр значение ячейки, для которой d..._output_time == 1 (см. Output parser), если get_pop_time - true, и подаю ее на вывод.

#### IN-OUT

В данном блоке я разъединяю четырех битный провод DATA_out по одному бит на провод. 
И каждый бит обрабатываю таким образом, что когда время вывода (get_pop_time (см. Parsing)), мы даем на вывод каждый бит DATA_out.
Иначе выдается undefined, чтобы не мешать IO_DATA_in. 
В основе этого, для каждого бита стоит два CMOS инвертора, которые состоят из одного P-type и одного N-type транзисторов, смотрящих друг на друга.
К их затворам проведено отрицание одно битного провода, к истоку P-type проведен get_pop_time, к истоку N-type проведено отрицание get_pop_time.
Таким образом, всегда на один из транзисторов подведена единица, а к другому нуль, в зависимости от значения get_pop_time.
А одно битный провод в свою очередь определяет какой из транзисторов открыть. 
И так как P_Type проводит только положительный сигнал, а N_type отрицательный, то получаем такую таблицу:

| get_pop_time | DATA_out | result    |
|--------------|----------|-----------|
| false        | true     | undefined |
| false        | false    | undefined |
| true         | true     | true      |
| true         | false    | false     |

Таким образом реализуется один IN-OUT провод.

#### Исправления

После review работы я сделал синхронизацию по высокому уровню, с помощью новой схемы inverse_dynamic_D_trigger, 
в которой синхронизация инвертирована, в отличие от старого dynamic_D_trigger, и заменил обычные на новые в схеме регистра.
Таким образом теперь значения записываются на C: 0->1, вместо 1->0, как было раньше. 
Сделал D_register с обычными D-триггерами для парсинга COMMAND, чтобы переключение на nop в высокой синхронизации не ломало счетчик.
Так же я поработал с временем get_pop_time и подвёл его к регистру на вывод, чтобы ответ записывался только когда (get или pop) и clk == true.
Это же время я использую в IN-OUT, чтобы при clk == false ничего не выводило. IN-OUT полностью переработан (см. IN-OUT),
оказалось что старый IN-OUT работал вообще некорректно. Остальное осталось в основном без изменений, кроме как, возможно, косметических :)


## VERILOG STRUCTURAL

В данной работе я просто всё переписал с Logisim версии. Не знаю даже, что тут сказать.
Названия всё те же. Единственное, что реализовал все гейты, на разное количество входов, но там нечего объяснять.

IN-OUT теперь реализован с помощью nmos()
```assign DATA_in = IO_DATA;

   nmos(IO_DATA[3], DATA_out[3], get_pop_time);
   nmos(IO_DATA[2], DATA_out[2], get_pop_time);
   nmos(IO_DATA[1], DATA_out[1], get_pop_time);
   nmos(IO_DATA[0], DATA_out[0], get_pop_time);
```

Никак не могу заставить работать счетчик при переключении с 0 на 100. Поэтому timeout. Я сдаюсь.

#### Исправления

Исправил всё, что исправил в logisim, но счетчик отказывается переходить с 0 в 100. 
Переписал IN-OUT. nmos() в Verilog работают точно так же, как и cmos инверторы, использованные в моей работе на logisim.
В принципе, работает корректно до тех пор, пока не требуется удалить нулевой элемент.

## VERILOG BEHAVIOUR 

У нас есть массив на 5 ячеек по 4 бита `reg [3:0] array [4:0];`, есть индекс текущей ячейки `reg [2:0] index;`, 
есть флаг `reg if_output;` чтобы отслеживать когда вывод, когда ввод для входа-выхода, `DATA_out, DATA_in` для ввода и вывода.

inout у нас обрабатывается таким образом:
```
assign DATA_in = IO_DATA;
assign IO_DATA = (if_output == 1 && CLK == 1) ? DATA_out : 4'bz;
```
Таким образом вход подключен к inout, а выход подключен если clk == 1 и сейчас производится вывод, иначе высокоимпедансное состояние.

Затем инициализируем array нулями, ставим index == 4, аналогично реализации в logisim.

Так же пишем условие always для RESET, когда оно 0->1, чтобы обнуляло весь array и ставит index = 4. `always @(posedge RESET)...`

После этого всегда, когда CLK 0->1: `always @(posedge CLK)...`, если RESET = 0, обрабатываем каждую команду:

- PUSH:
  - увеличиваем index на 1 по модулю пять
  - кладем значение в массив array на место index
  - флаг вывода ставим в нуль
- POP:
  - в вывод подаем текущий элемент
  - уменьшаем индекс на 1, рассматривая случай, когда индекс равен нулю и за ним будет следовать 4
  - флаг вывода ставим в единицу
- GET:
  - присваиваем переменной временного индекса temp_ind настоящий index
  - вычитаем из temp_ind единицу INDEX раз, пока не дойдем до элемента, который пойдет на вывод, обрабатывая случаи модулярной арифметики, когда после 0 следует 4
  - в вывод подаем элемент под номером temp_ind
  - флаг вывода ставим в единицу
- NOP:
  - флаг вывода обязательно ставим в нуль


#### Исправления
Переписал всё более похоже на logisim версию. Это касается в основном индекса текущего элемента. Теперь он указывает всегда на вершину стека. 
Не уверен на счёт проверки `if (RESET == 0)` перед обработкой команд, нужна ли она, но в logisim работает именно так. 

### Примечания по оформлению (можно удалить после создания отчёта)

1. Не нужно вставлять своё описание как quote (цитату). 
2. Старайтесь также разбивать ваш текст на логические разделы и отделять мысли заголовками.
3. Если хочется вставить фрагменты кода, то делаете это блоком кода. Если же ссылаетесь на код, то рекомендуется это делать через permalink на файлы в репозитории.
4. Можно пользоваться всеми возможностями Github Markdown.
5. Никаких фоток в отчёте, ровно, как и скринов полного экрана. Это больно смотреть \(
6. Если вы хотите вставить изображение из сети, то не нужно его грузить в репозиторий.
7. В случае описание подсхем Logisim, если вы просто ссылаетесь на подсхему в целом, то достаточно указать назвнаие подсхемы из проекта. Если же вы описываете какой-то небольшой фрагмент схемы, то лучше его вставить в виде рисунка в отчёт.
